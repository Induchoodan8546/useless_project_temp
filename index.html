<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chithraguptan 3D</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- MediaPipe Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden;
            background-color: #1a202c;
        }

        canvas {
            display: block;
        }

        #mood-display,
        #instructions,
        #llm-response-box,
        #cheer-up-btn,
        #control-switch-btn {
            position: absolute;
            z-index: 10;
        }

        #mood-display {
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            color: white;
            font-size: 1.25rem;
            font-weight: bold;
        }

        #instructions {
            bottom: 20px;
            left: 20px;
            padding: 10px 20px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            color: white;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        #llm-response-box {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 400px;
            padding: 20px;
            background-color: rgba(255, 255, 255, 0.9);
            color: #333;
            border-radius: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            text-align: center;
            display: none;
        }

        #llm-response-box p {
            margin: 0 0 10px 0;
            font-size: 1.1rem;
            font-style: italic;
        }

        #llm-response-box .close-btn {
            background-color: #f44336;
            color: white;
            border: none;
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 5px;
            font-size: 0.9rem;
        }
    </style>
</head>

<body>
    <div id="mood-display">Mood: Content</div>
    <div id="instructions">
        <p><strong>INSTRUCTIONS:</strong></p>
        <p>Move mouse slowly: Content (Green)</p>
        <p>Move mouse fast: Playful (Lime)</p>
        <p>No movement for 3s: Bored (Blue)</p>
        <p>Click head 3 times: Angry (Rebellious)</p>
        <p><strong>Hand Gestures:</strong></p>
        <p>Pinch fingers ü§è: Playful</p>
        <p>Make a fist ‚úä: Angry</p>
    </div>
    <div id="llm-response-box">
        <p id="llm-response-text">Chithraguptan is thinking...</p>
        <button class="close-btn">Close</button>
    </div>
    <button id="cheer-up-btn"
        class="absolute top-20 right-20 px-6 py-3 bg-gradient-to-r from-blue-500 to-purple-500 text-white font-bold rounded-full shadow-lg hover:from-blue-600 hover:to-purple-600 transition-all duration-300 transform hover:scale-105">
        Cheer Up! ‚ú®
    </button>

    <!-- New elements for hand tracking -->
    <video class="input_video" style="display: none;"></video>
    <button id="control-switch-btn"
        class="absolute bottom-20 right-20 px-6 py-3 bg-gradient-to-r from-teal-400 to-blue-500 text-white font-bold rounded-full shadow-lg hover:from-teal-500 hover:to-blue-600 transition-all duration-300 transform hover:scale-105">
        Switch to Hand Control üñêÔ∏è
    </button>

    <script>
        // --- Core Three.js Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setClearColor(0x1a202c);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        camera.position.z = 25;

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(0, 10, 10);
        scene.add(directionalLight);

        // --- Chithraguptan's 3D Body ---
        const bodyParts = [], eyes = [], arms = [], legs = [], eyebrows = [];
        let mouth;
        const headGeometry = new THREE.SphereGeometry(2, 32, 32);
        const headMaterial = new THREE.MeshLambertMaterial({ color: 0x32cd32 });
        const head = new THREE.Mesh(headGeometry, headMaterial);
        scene.add(head);
        bodyParts.push(head);
        const eyeGeometry = new THREE.SphereGeometry(0.4, 16, 16);
        const eyeMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
        const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial.clone());
        leftEye.position.set(-0.7, 0.5, 1.6);
        head.add(leftEye);
        eyes.push(leftEye);
        const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial.clone());
        rightEye.position.set(0.7, 0.5, 1.6);
        head.add(rightEye);
        eyes.push(rightEye);
        const mouthGeometry = new THREE.TorusGeometry(0.8, 0.1, 8, 16, Math.PI);
        const mouthMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
        mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
        mouth.position.set(0, -0.6, 1.8);
        mouth.rotation.x = -Math.PI / 16;
        mouth.rotation.z = -Math.PI / 2;
        head.add(mouth);
        const eyebrowGeometry = new THREE.BoxGeometry(1, 0.15, 0.1);
        const eyebrowMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
        const leftEyebrow = new THREE.Mesh(eyebrowGeometry, eyebrowMaterial.clone());
        leftEyebrow.position.set(-0.7, 1.3, 1.8);
        head.add(leftEyebrow);
        eyebrows.push(leftEyebrow);
        const rightEyebrow = new THREE.Mesh(eyebrowGeometry, eyebrowMaterial.clone());
        rightEyebrow.position.set(0.7, 1.3, 1.8);
        head.add(rightEyebrow);
        eyebrows.push(rightEyebrow);
        for (let i = 0; i < 10; i++) {
            const scale = 1.0 - (i / 10) * 0.5;
            const segmentRadius = 1 * scale;
            const bodyGeometry = new THREE.SphereGeometry(segmentRadius, 32, 32);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x32cd32 });
            const bodySegment = new THREE.Mesh(bodyGeometry, bodyMaterial);
            const prevY = bodyParts[i] ? bodyParts[i].position.y : 0;
            const prevRadius = bodyParts[i] ? bodyParts[i].geometry.parameters.radius : 2;
            bodySegment.position.y = prevY - (prevRadius + segmentRadius + 0.5);
            scene.add(bodySegment);
            bodyParts.push(bodySegment);
            if (i === 0) {
                const armGeometry = new THREE.CylinderGeometry(0.2, 0.2, 1.5, 8);
                const armMaterial = new THREE.MeshLambertMaterial({ color: 0x32cd32 });
                const leftArm = new THREE.Mesh(armGeometry, armMaterial.clone());
                leftArm.position.set(-1.5, 0, 0);
                bodySegment.add(leftArm);
                arms.push(leftArm);
                const rightArm = new THREE.Mesh(armGeometry, armMaterial.clone());
                rightArm.position.set(1.5, 0, 0);
                bodySegment.add(rightArm);
                arms.push(rightArm);
            }
            if (i === 1) {
                const legGeometry = new THREE.CylinderGeometry(0.3, 0.3, 2, 8);
                const legMaterial = new THREE.MeshLambertMaterial({ color: 0x32cd32 });
                const leftLeg = new THREE.Mesh(legGeometry, legMaterial.clone());
                leftLeg.position.set(-1.2, -1, 0);
                leftLeg.rotation.z = Math.PI / 8;
                bodySegment.add(leftLeg);
                legs.push(leftLeg);
                const rightLeg = new THREE.Mesh(legGeometry, legMaterial.clone());
                rightLeg.position.set(1.2, -1, 0);
                rightLeg.rotation.z = -Math.PI / 8;
                bodySegment.add(rightLeg);
                legs.push(rightLeg);
            }
        }

        // --- Game State Variables ---
        let controlMode = 'mouse'; // 'mouse' or 'hand'
        let handTargetPos = new THREE.Vector3(0, 0, 0);
        let mood = "content", lastMousePos = { x: window.innerWidth / 2, y: window.innerHeight / 2 }, mouseSpeed = 0, lastMovementTime = Date.now(), clickCount = 0, lastClickTime = 0, angryTimer = 0, randomTarget = new THREE.Vector3(0, 0, 0), lastTargetChange = Date.now(), llmIsLoading = false;
        const moodDisplay = document.getElementById('mood-display'), cheerUpBtn = document.getElementById('cheer-up-btn'), llmResponseBox = document.getElementById('llm-response-box'), llmResponseText = document.getElementById('llm-response-text'), closeBtn = llmResponseBox.querySelector('.close-btn'), controlSwitchBtn = document.getElementById('control-switch-btn');
        const moodColors = { "bored": 0x646464, "content": 0x32CD32, "playful": 0x00ff00, "sad": 0x464696, "angry": 0xff3232 };

        // --- LLM API Integration (omitted for brevity, same as before) ---
        async function getLlmResponse(prompt) { /* ... same code ... */ }

        // --- MediaPipe Hand Tracking Setup ---
        const videoElement = document.querySelector('.input_video');
        let hands, camera_mp;

        function onResults(results) {
            if (controlMode !== 'hand') return;

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];

                const indexTip = landmarks[8];
                const thumbTip = landmarks[4];
                const middleTip = landmarks[12];
                const ringTip = landmarks[16];
                const pinkyTip = landmarks[20];

                const indexPip = landmarks[6];
                const middlePip = landmarks[10];
                const ringPip = landmarks[14];
                const pinkyPip = landmarks[18];

                handTargetPos.set((1 - indexTip.x) * 40 - 20, -(indexTip.y) * 40 + 20, 0);
                lastMovementTime = Date.now();

                const pinchDistance = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y, indexTip.z - thumbTip.z);

                const isFist = indexTip.y > indexPip.y &&
                    middleTip.y > middlePip.y &&
                    ringTip.y > ringPip.y &&
                    pinkyTip.y > pinkyPip.y;

                if (isFist) {
                    mood = "angry";
                    angryTimer = Date.now();
                } else if (pinchDistance < 0.05) {
                    mood = "playful";
                }
            }
        }

        // --- Event Listeners ---
        controlSwitchBtn.addEventListener('click', () => {
            if (controlMode === 'mouse') {
                controlMode = 'hand';
                controlSwitchBtn.innerHTML = "Switch to Mouse Control üñ±Ô∏è";
                camera_mp.start();
            } else {
                controlMode = 'mouse';
                controlSwitchBtn.innerHTML = "Switch to Hand Control üñêÔ∏è";
                camera_mp.stop();
            }
        });

        window.addEventListener('mousemove', (event) => {
            if (controlMode !== 'mouse') return;
            const dx = event.clientX - lastMousePos.x;
            const dy = event.clientY - lastMousePos.y;
            mouseSpeed = Math.sqrt(dx * dx + dy * dy);
            lastMousePos = { x: event.clientX, y: event.clientY };
            lastMovementTime = Date.now();
        });

        window.addEventListener('mousedown', (event) => {
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(bodyParts, true);

            if (intersects.length > 0) {
                const now = Date.now();
                if (now - lastClickTime < 500) {
                    clickCount++;
                } else {
                    clickCount = 1;
                }
                lastClickTime = now;
            }
        });

        cheerUpBtn.addEventListener('click', () => { /* ... same code ... */ });
        closeBtn.addEventListener('click', () => { /* ... same code ... */ });

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            const now = Date.now();
            const timeSinceMovement = (now - lastMovementTime) / 1000;
            if (clickCount >= 3 && now - lastClickTime < 1500) { mood = "angry"; angryTimer = now; clickCount = 0; }

            if (mood === "angry") {
                if (mouseSpeed < 5 && now - angryTimer > 3000) { mood = "content"; }
                else if (now - angryTimer > 10000) { mood = "content"; }
            } else if (mood === 'playful') {
                if (timeSinceMovement > 5) {
                    mood = 'content';
                }
            } else {
                if (mouseSpeed > 50 && controlMode === 'mouse') { mood = "playful"; }
                else if (timeSinceMovement > 15) { mood = "angry"; angryTimer = now; }
                else if (timeSinceMovement > 10) { mood = "sad"; }
                else if (timeSinceMovement > 3) { mood = "bored"; }
                else { mood = "content"; }
            }
            moodDisplay.innerText = `Mood: ${mood.charAt(0).toUpperCase() + mood.slice(1)}`;

            const targetPosition = new THREE.Vector3();
            if (mood === "angry") {
                if (now - lastTargetChange > 2000) { randomTarget.set((Math.random() - 0.5) * 50, (Math.random() - 0.5) * 50, (Math.random() - 0.5) * 50); lastTargetChange = now; }
                targetPosition.copy(randomTarget);
            } else {
                if (controlMode === 'mouse') {
                    targetPosition.set((lastMousePos.x / window.innerWidth) * 40 - 20, -(lastMousePos.y / window.innerHeight) * 40 + 20, 0);
                } else {
                    targetPosition.copy(handTargetPos);
                }
            }
            head.position.lerp(targetPosition, 0.05);
            for (let i = 1; i < bodyParts.length; i++) { bodyParts[i].position.lerp(bodyParts[i - 1].position, 0.1); }

            const pulse = 1 + Math.sin(now * 0.005) * 0.1;
            head.scale.set(pulse, pulse, pulse);
            const time = now * 0.01;
            if (mood === 'playful') {
                arms.forEach(arm => { arm.rotation.z = Math.sin(time * 2); }); legs.forEach(leg => { leg.rotation.x = Math.sin(time); });
            } else if (mood === 'angry') {
                arms.forEach(arm => { arm.rotation.x = -Math.PI / 2; }); legs.forEach(leg => { leg.rotation.x = 0; });
            } else { arms.forEach(arm => { arm.rotation.set(0, 0, 0); }); legs.forEach(leg => { leg.rotation.set(0, 0, Math.PI / 8 * (leg.position.x > 0 ? -1 : 1)); }); }
            const sadColor = new THREE.Color(0x5555ff);
            if (mood === 'sad') { eyes.forEach(eye => eye.material.color.lerp(sadColor, 0.1)); } else { eyes.forEach(eye => eye.material.color.lerp(new THREE.Color(0x000000), 0.1)); }
            const smileRotationZ = -Math.PI / 2, frownRotationZ = Math.PI / 2;
            switch (mood) {
                case 'content': case 'playful': mouth.rotation.z = smileRotationZ; mouth.scale.set(1, 1, 1); eyebrows.forEach(b => b.visible = false); break;
                case 'sad': mouth.rotation.z = frownRotationZ; mouth.scale.set(0.7, 1, 1); eyebrows.forEach(b => b.visible = true); eyebrows[0].rotation.z = -Math.PI / 8; eyebrows[1].rotation.z = Math.PI / 8; break;
                case 'angry': mouth.rotation.z = frownRotationZ; mouth.scale.set(1, 0.7, 1); eyebrows.forEach(b => b.visible = true); eyebrows[0].rotation.z = Math.PI / 8; eyebrows[1].rotation.z = -Math.PI / 8; break;
                case 'bored': mouth.rotation.z = smileRotationZ; mouth.scale.set(1, 0.1, 1); eyebrows.forEach(b => b.visible = false); break;
            }
            const currentColor = new THREE.Color(head.material.color), targetColor = new THREE.Color(moodColors[mood]);
            currentColor.lerp(targetColor, 0.05);
            bodyParts.forEach(part => { part.material.color.copy(currentColor); part.children.forEach(child => { if (child.isMesh && child.material) { if (eyes.indexOf(child) === -1 && child !== mouth && eyebrows.indexOf(child) === -1) { child.material.color.copy(currentColor); } } }); });

            renderer.render(scene, camera);
        }

        // **FIX**: Initialize everything on window load to prevent race conditions
        window.onload = () => {
            // Initialize MediaPipe Hands
            hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
            hands.onResults(onResults);

            // Initialize MediaPipe Camera
            camera_mp = new Camera(videoElement, { onFrame: async () => { await hands.send({ image: videoElement }); }, width: 1280, height: 720 });

            // Start the main animation loop
            animate();
        };

        window.addEventListener('resize', () => {
            const newWidth = window.innerWidth;
            const newHeight = window.innerHeight;
            renderer.setSize(newWidth, newHeight);
            camera.aspect = newWidth / newHeight;
            camera.updateProjectionMatrix();
        });
    </script>
</body>

</html>
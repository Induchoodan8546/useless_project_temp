<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chithraguptan 3D</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden;
            background-color: #1a202c;
            /* Dark background color */
        }

        canvas {
            display: block;
        }

        #mood-display {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            color: white;
            font-size: 1.25rem;
            font-weight: bold;
            z-index: 10;
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            padding: 10px 20px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            color: white;
            font-size: 0.9rem;
            line-height: 1.5;
            z-index: 10;
        }

        #llm-response-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 400px;
            padding: 20px;
            background-color: rgba(255, 255, 255, 0.9);
            color: #333;
            border-radius: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            text-align: center;
            display: none;
            /* Initially hidden */
            z-index: 10;
        }

        #llm-response-box p {
            margin: 0 0 10px 0;
            font-size: 1.1rem;
            font-style: italic;
        }

        #llm-response-box .close-btn {
            background-color: #f44336;
            color: white;
            border: none;
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 5px;
            font-size: 0.9rem;
        }

        #cheer-up-btn {
            z-index: 10;
        }
    </style>
</head>

<body>
    <div id="mood-display">Mood: Content</div>
    <div id="instructions">
        <p><strong>INSTRUCTIONS:</strong></p>
        <p>Move mouse slowly: Content (Green)</p>
        <p>Move mouse fast: Playful (Lime)</p>
        <p>No movement for 3s: Bored (Blue)</p>
        <p>No movement for 10s: Sad (Purple)</p>
        <p>No movement for 15s: Angry (Red)</p>
        <p>Click head 3 times: Angry (Rebellious)</p>
        <p>Calm an angry pet with slow, deliberate movement.</p>
    </div>
    <div id="llm-response-box">
        <p id="llm-response-text">Chithraguptan is thinking...</p>
        <button class="close-btn">Close</button>
    </div>
    <button id="cheer-up-btn"
        class="absolute top-20 right-20 px-6 py-3 bg-gradient-to-r from-blue-500 to-purple-500 text-white font-bold rounded-full shadow-lg hover:from-blue-600 hover:to-purple-600 transition-all duration-300 transform hover:scale-105">
        Cheer Up! âœ¨
    </button>
    <script>
        // --- Core Three.js Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setClearColor(0x1a202c); // Match background
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        camera.position.z = 25;

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(0, 10, 10);
        scene.add(directionalLight);

        // --- Chithraguptan's 3D Body ---
        const bodyParts = [];
        const eyes = [];
        const arms = [];
        const legs = [];
        let mouth;

        const numSegments = 10;
        const segmentGap = 0.5;

        // Create the head
        const headGeometry = new THREE.SphereGeometry(2, 32, 32);
        const headMaterial = new THREE.MeshLambertMaterial({ color: 0x32cd32 });
        const head = new THREE.Mesh(headGeometry, headMaterial);
        scene.add(head);
        bodyParts.push(head);

        // Create Eyes and add them to the head
        const eyeGeometry = new THREE.SphereGeometry(0.4, 16, 16);
        const eyeMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 }); // Black eyes

        const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial.clone());
        leftEye.position.set(-0.7, 0.5, 1.6); // x, y, z relative to head
        head.add(leftEye); // Attach eye to head
        eyes.push(leftEye);

        const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial.clone());
        rightEye.position.set(0.7, 0.5, 1.6);
        head.add(rightEye); // Attach eye to head
        eyes.push(rightEye);

        // Create Mouth and add it to the head
        const mouthGeometry = new THREE.TorusGeometry(0.8, 0.15, 8, 16, Math.PI); // A semi-circle
        const mouthMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
        mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
        mouth.position.set(0, -0.5, 1.5); // Position it below the eyes
        mouth.rotation.z = Math.PI; // Start with a frown (will be updated)
        head.add(mouth); // Attach mouth to head

        // Create the body segments (tapering into a tail)
        for (let i = 0; i < numSegments; i++) {
            const scale = 1.0 - (i / numSegments) * 0.5; // Decrease scale for each segment
            const segmentRadius = 1 * scale;
            const bodyGeometry = new THREE.SphereGeometry(segmentRadius, 32, 32);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x32cd32 });
            const bodySegment = new THREE.Mesh(bodyGeometry, bodyMaterial);

            // Initial positioning
            const prevY = bodyParts[i] ? bodyParts[i].position.y : 0;
            const prevRadius = bodyParts[i] ? bodyParts[i].geometry.parameters.radius : 2;
            bodySegment.position.y = prevY - (prevRadius + segmentRadius + segmentGap);

            scene.add(bodySegment);
            bodyParts.push(bodySegment);

            // Add arms to the first body segment
            if (i === 0) {
                const armGeometry = new THREE.CylinderGeometry(0.2, 0.2, 1.5, 8);
                const armMaterial = new THREE.MeshLambertMaterial({ color: 0x32cd32 });

                const leftArm = new THREE.Mesh(armGeometry, armMaterial.clone());
                leftArm.position.set(-1.5, 0, 0);
                bodySegment.add(leftArm); // Attach arm to segment
                arms.push(leftArm);

                const rightArm = new THREE.Mesh(armGeometry, armMaterial.clone());
                rightArm.position.set(1.5, 0, 0);
                bodySegment.add(rightArm); // Attach arm to segment
                arms.push(rightArm);
            }
            // Add legs to the second body segment
            if (i === 1) {
                const legGeometry = new THREE.CylinderGeometry(0.3, 0.3, 2, 8);
                const legMaterial = new THREE.MeshLambertMaterial({ color: 0x32cd32 });

                const leftLeg = new THREE.Mesh(legGeometry, legMaterial.clone());
                leftLeg.position.set(-1.2, -1, 0);
                leftLeg.rotation.z = Math.PI / 8;
                bodySegment.add(leftLeg); // Attach leg to segment
                legs.push(leftLeg);

                const rightLeg = new THREE.Mesh(legGeometry, legMaterial.clone());
                rightLeg.position.set(1.2, -1, 0);
                rightLeg.rotation.z = -Math.PI / 8;
                bodySegment.add(rightLeg); // Attach leg to segment
                legs.push(rightLeg);
            }
        }


        // --- Game State Variables ---
        let mood = "content";
        let lastMousePos = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
        let mouseSpeed = 0;
        let lastMovementTime = Date.now();
        let clickCount = 0;
        let lastClickTime = 0;
        let angryTimer = 0;
        let randomTarget = new THREE.Vector3(0, 0, 0);
        let lastTargetChange = Date.now();
        let llmIsLoading = false;

        const moodDisplay = document.getElementById('mood-display');
        const cheerUpBtn = document.getElementById('cheer-up-btn');
        const llmResponseBox = document.getElementById('llm-response-box');
        const llmResponseText = document.getElementById('llm-response-text');
        const closeBtn = llmResponseBox.querySelector('.close-btn');

        const moodColors = {
            "bored": 0x646464,
            "content": 0x32CD32,
            "playful": 0x00ff00,
            "sad": 0x464696,
            "angry": 0xff3232
        };

        // --- LLM API Integration ---
        async function getLlmResponse(prompt) {
            if (llmIsLoading) return;
            llmIsLoading = true;
            llmResponseBox.style.display = 'block';
            llmResponseText.innerText = 'Chithraguptan is thinking...';
            cheerUpBtn.disabled = true;

            let chatHistory = [];
            chatHistory.push({ role: "user", parts: [{ text: prompt }] });
            const payload = { contents: chatHistory };
            const apiKey = ""; // IMPORTANT: Add your API Key here
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${apiKey}`;

            let retries = 0;
            const maxRetries = 5;
            const initialDelay = 1000;

            const makeApiCall = async () => {
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.status === 429) {
                        if (retries < maxRetries) {
                            const delay = initialDelay * Math.pow(2, retries) + Math.random() * 1000;
                            retries++;
                            await new Promise(resolve => setTimeout(resolve, delay));
                            return await makeApiCall();
                        } else {
                            throw new Error('API request failed after multiple retries.');
                        }
                    }

                    const result = await response.json();
                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        const text = result.candidates[0].content.parts[0].text;
                        llmResponseText.innerText = text;
                    } else {
                        llmResponseText.innerText = "I'm not sure what to say right now.";
                    }
                } catch (error) {
                    console.error('API Error:', error);
                    llmResponseText.innerText = "An error occurred. Please try again.";
                } finally {
                    llmIsLoading = false;
                    cheerUpBtn.disabled = false;
                }
            };
            await makeApiCall();
        }

        // --- Event Listeners ---
        window.addEventListener('mousemove', (event) => {
            const dx = event.clientX - lastMousePos.x;
            const dy = event.clientY - lastMousePos.y;
            mouseSpeed = Math.sqrt(dx * dx + dy * dy);
            lastMousePos = { x: event.clientX, y: event.clientY };
            lastMovementTime = Date.now();
        });

        window.addEventListener('mousedown', (event) => {
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(bodyParts, true);

            if (intersects.length > 0) {
                const now = Date.now();
                if (now - lastClickTime < 500) {
                    clickCount++;
                } else {
                    clickCount = 1;
                }
                lastClickTime = now;
            }
        });

        cheerUpBtn.addEventListener('click', () => {
            let prompt = "";
            switch (mood) {
                case "bored":
                    prompt = "Provide a fun and engaging activity for a pet that seems bored. The response should be concise and no more than 20 words.";
                    break;
                case "sad":
                    prompt = "Generate a kind and uplifting message to comfort a pet that is sad. The response should be concise and no more than 20 words.";
                    break;
                case "angry":
                    prompt = "Offer a single, calming technique or piece of advice to soothe an angry pet. The response should be concise and no more than 20 words.";
                    break;
                default:
                    prompt = "Generate a short, playful, and fun fact about a lizard or gecko.";
                    break;
            }
            getLlmResponse(prompt);
        });

        closeBtn.addEventListener('click', () => {
            llmResponseBox.style.display = 'none';
        });

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            // --- Mood Logic ---
            const now = Date.now();
            const timeSinceMovement = (now - lastMovementTime) / 1000;

            if (clickCount >= 3 && now - lastClickTime < 1500) {
                mood = "angry";
                angryTimer = now;
                clickCount = 0;
            }

            if (mood === "angry") {
                if (mouseSpeed < 5 && now - angryTimer > 3000) {
                    mood = "content";
                } else if (now - angryTimer > 10000) {
                    mood = "content";
                }
            } else {
                if (mouseSpeed > 50) {
                    mood = "playful";
                } else if (timeSinceMovement > 15) {
                    mood = "angry";
                    angryTimer = now;
                } else if (timeSinceMovement > 10) {
                    mood = "sad";
                } else if (timeSinceMovement > 3) {
                    mood = "bored";
                } else {
                    mood = "content";
                }
            }

            moodDisplay.innerText = `Mood: ${mood.charAt(0).toUpperCase() + mood.slice(1)}`;

            // --- Movement Logic ---
            const targetPosition = new THREE.Vector3();
            if (mood === "angry") {
                if (now - lastTargetChange > 2000) {
                    randomTarget.set(
                        (Math.random() - 0.5) * 50,
                        (Math.random() - 0.5) * 50,
                        (Math.random() - 0.5) * 50
                    );
                    lastTargetChange = now;
                }
                targetPosition.copy(randomTarget);
            } else {
                targetPosition.set(
                    (lastMousePos.x / window.innerWidth) * 40 - 20,
                    -(lastMousePos.y / window.innerHeight) * 40 + 20,
                    0
                );
            }

            const headTarget = targetPosition.clone();
            bodyParts[0].position.lerp(headTarget, 0.05);

            for (let i = 1; i < bodyParts.length; i++) {
                const prev = bodyParts[i - 1];
                const current = bodyParts[i];
                current.position.lerp(prev.position, 0.1);
            }

            // --- Visual Effects ---
            const pulse = 1 + Math.sin(Date.now() * 0.005) * 0.1;
            // We don't pulse the whole body anymore to keep limbs stable
            head.scale.set(pulse, pulse, pulse);

            // Animate limbs, face, and mouth based on mood
            const time = Date.now() * 0.01;

            // Limb Animation
            if (mood === 'playful') {
                arms.forEach(arm => { arm.rotation.z = Math.sin(time * 2); }); // Waving
                legs.forEach(leg => { leg.rotation.x = Math.sin(time); });     // Kicking
            } else if (mood === 'angry') {
                arms.forEach(arm => { arm.rotation.x = -Math.PI / 2; });       // Fists forward
                legs.forEach(leg => { leg.rotation.x = 0; });
            } else {
                // Return to neutral pose
                arms.forEach(arm => { arm.rotation.set(0, 0, 0); });
                legs.forEach(leg => { leg.rotation.set(0, 0, Math.PI / 8 * (leg.position.x > 0 ? -1 : 1)); });
            }

            // Eye Animation
            const sadColor = new THREE.Color(0x5555ff); // Bluish tint for sad eyes
            if (mood === 'sad') {
                eyes.forEach(eye => eye.material.color.lerp(sadColor, 0.1));
            } else {
                eyes.forEach(eye => eye.material.color.lerp(new THREE.Color(0x000000), 0.1));
            }

            // Mouth Expression Animation
            switch (mood) {
                case 'content':
                case 'playful':
                    mouth.rotation.z = 0; // Smile
                    mouth.scale.set(1, 1, 1);
                    break;
                case 'sad':
                    mouth.rotation.z = Math.PI; // Frown
                    mouth.scale.set(0.7, 1, 1); // Narrower frown
                    break;
                case 'angry':
                    mouth.rotation.z = Math.PI; // Frown
                    mouth.scale.set(1, 0.7, 1); // Squished frown
                    break;
                case 'bored':
                    mouth.rotation.z = 0;
                    mouth.scale.set(1, 0.1, 1); // Flat line
                    break;
            }

            // Lerp color for all body parts
            const currentColor = new THREE.Color(head.material.color);
            const targetColor = new THREE.Color(moodColors[mood]);
            currentColor.lerp(targetColor, 0.05);

            // Apply color to all parts, including arms and legs
            bodyParts.forEach(part => {
                part.material.color.copy(currentColor);
                part.children.forEach(child => {
                    if (child.isMesh && child.material) {
                        // This will color the attached arms and legs, but not the eyes or mouth
                        if (eyes.indexOf(child) === -1 && child !== mouth) {
                            child.material.color.copy(currentColor);
                        }
                    }
                });
            });


            renderer.render(scene, camera);
        }

        window.onload = animate;

        // --- Handle window resize ---
        window.addEventListener('resize', () => {
            const newWidth = window.innerWidth;
            const newHeight = window.innerHeight;
            renderer.setSize(newWidth, newHeight);
            camera.aspect = newWidth / newHeight;
            camera.updateProjectionMatrix();
        });
    </script>
</body>

</html>
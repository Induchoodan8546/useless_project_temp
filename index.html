<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chithraguptan 3D</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- MediaPipe Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden;
            background-color: #1a202c;
        }

        canvas {
            display: block;
        }

        #mood-display,
        #instructions,
        #llm-response-box,
        #cheer-up-btn,
        #control-switch-btn,
        #debug-info,
        #debug-toggle-btn {
            position: absolute;
            z-index: 10;
        }

        #mood-display {
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            color: white;
            font-size: 1.25rem;
            font-weight: bold;
        }

        #debug-info {
            top: 80px;
            left: 20px;
            padding: 10px 20px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            color: white;
            font-size: 0.8rem;
            display: none;
        }

        #instructions {
            bottom: 20px;
            left: 20px;
            padding: 10px 20px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            color: white;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        #llm-response-box {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 400px;
            padding: 20px;
            background-color: rgba(255, 255, 255, 0.9);
            color: #333;
            border-radius: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            text-align: center;
            display: none;
        }

        #llm-response-box p {
            margin: 0 0 10px 0;
            font-size: 1.1rem;
            font-style: italic;
        }

        #llm-response-box .close-btn {
            background-color: #f44336;
            color: white;
            border: none;
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 5px;
            font-size: 0.9rem;
        }

        .input_video {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 160px;
            height: 120px;
            border: 2px solid #fff;
            border-radius: 8px;
            display: none;
        }
    </style>
</head>

<body>
    <div id="mood-display">Mood: Content</div>
    <div id="debug-info">
        <div>Control Mode: <span id="control-mode">Mouse</span></div>
        <div>Hand Detected: <span id="hand-status">No</span></div>
        <div>Gesture: <span id="gesture-status">None</span></div>
        <div>Camera: <span id="camera-status">Off</span></div>
    </div>
    <div id="instructions">
        <p><strong>INSTRUCTIONS:</strong></p>
        <p>Move mouse slowly: Content (Green)</p>
        <p>Move mouse fast: Playful (Lime)</p>
        <p>No movement for 3s: Bored (Blue)</p>
        <p>Click head 3 times: Angry (Rebellious)</p>
        <p><strong>Hand Gestures:</strong></p>
        <p>Point with index finger: Navigate</p>
        <p>Pinch fingers ü§è: Playful</p>
        <p>Make a fist ‚úä: Angry</p>
        <p>Open palm ‚úã: Content</p>
    </div>
    <div id="llm-response-box">
        <p id="llm-response-text">Chithraguptan is thinking...</p>
        <button class="close-btn">Close</button>
    </div>
    <button id="cheer-up-btn"
        class="absolute top-20 right-20 px-6 py-3 bg-gradient-to-r from-blue-500 to-purple-500 text-white font-bold rounded-full shadow-lg hover:from-blue-600 hover:to-purple-600 transition-all duration-300 transform hover:scale-105">
        Cheer Up! ‚ú®
    </button>

    <!-- Video element for hand tracking -->
    <video class="input_video"></video>
    <button id="control-switch-btn"
        class="absolute bottom-20 right-20 px-6 py-3 bg-gradient-to-r from-teal-400 to-blue-500 text-white font-bold rounded-full shadow-lg hover:from-teal-500 hover:to-blue-600 transition-all duration-300 transform hover:scale-105">
        Switch to Hand Control üñêÔ∏è
    </button>
    <button id="debug-toggle-btn"
        class="absolute bottom-40 right-20 px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700 transition-all duration-300">
        Debug Info
    </button>

    <script>
        window.onload = () => {
            // --- Core Three.js Setup ---
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setClearColor(0x1a202c);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            camera.position.z = 25;

            // --- Lighting ---
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(0, 10, 10);
            scene.add(directionalLight);

            // --- Chithraguptan's 3D Body ---
            const bodyParts = [], eyes = [], arms = [], legs = [], eyebrows = [];
            let mouth;

            // Head
            const headGeometry = new THREE.SphereGeometry(2, 32, 32);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0x32cd32 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            scene.add(head);
            bodyParts.push(head);

            // Eyes
            const eyeGeometry = new THREE.SphereGeometry(0.4, 16, 16);
            const eyeMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial.clone());
            leftEye.position.set(-0.7, 0.5, 1.6);
            head.add(leftEye);
            eyes.push(leftEye);
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial.clone());
            rightEye.position.set(0.7, 0.5, 1.6);
            head.add(rightEye);
            eyes.push(rightEye);

            // Mouth
            const mouthGeometry = new THREE.TorusGeometry(0.8, 0.1, 8, 16, Math.PI);
            const mouthMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
            mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
            mouth.position.set(0, -0.6, 1.8);
            mouth.rotation.x = -Math.PI / 16;
            mouth.rotation.z = -Math.PI / 2;
            head.add(mouth);

            // Eyebrows
            const eyebrowGeometry = new THREE.BoxGeometry(1, 0.15, 0.1);
            const eyebrowMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
            const leftEyebrow = new THREE.Mesh(eyebrowGeometry, eyebrowMaterial.clone());
            leftEyebrow.position.set(-0.7, 1.3, 1.8);
            head.add(leftEyebrow);
            eyebrows.push(leftEyebrow);
            const rightEyebrow = new THREE.Mesh(eyebrowGeometry, eyebrowMaterial.clone());
            rightEyebrow.position.set(0.7, 1.3, 1.8);
            head.add(rightEyebrow);
            eyebrows.push(rightEyebrow);

            // Body segments with arms and legs
            for (let i = 0; i < 10; i++) {
                const scale = 1.0 - (i / 10) * 0.5;
                const segmentRadius = 1 * scale;
                const bodyGeometry = new THREE.SphereGeometry(segmentRadius, 32, 32);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x32cd32 });
                const bodySegment = new THREE.Mesh(bodyGeometry, bodyMaterial);
                const prevY = bodyParts[i] ? bodyParts[i].position.y : 0;
                const prevRadius = bodyParts[i] ? bodyParts[i].geometry.parameters.radius : 2;
                bodySegment.position.y = prevY - (prevRadius + segmentRadius + 0.5);
                scene.add(bodySegment);
                bodyParts.push(bodySegment);

                if (i === 0) {
                    const armGeometry = new THREE.CylinderGeometry(0.2, 0.2, 1.5, 8);
                    const armMaterial = new THREE.MeshLambertMaterial({ color: 0x32cd32 });
                    const leftArm = new THREE.Mesh(armGeometry, armMaterial.clone());
                    leftArm.position.set(-1.5, 0, 0);
                    bodySegment.add(leftArm);
                    arms.push(leftArm);
                    const rightArm = new THREE.Mesh(armGeometry, armMaterial.clone());
                    rightArm.position.set(1.5, 0, 0);
                    bodySegment.add(rightArm);
                    arms.push(rightArm);
                }
                if (i === 1) {
                    const legGeometry = new THREE.CylinderGeometry(0.3, 0.3, 2, 8);
                    const legMaterial = new THREE.MeshLambertMaterial({ color: 0x32cd32 });
                    const leftLeg = new THREE.Mesh(legGeometry, legMaterial.clone());
                    leftLeg.position.set(-1.2, -1, 0);
                    leftLeg.rotation.z = Math.PI / 8;
                    bodySegment.add(leftLeg);
                    legs.push(leftLeg);
                    const rightLeg = new THREE.Mesh(legGeometry, legMaterial.clone());
                    rightLeg.position.set(1.2, -1, 0);
                    rightLeg.rotation.z = -Math.PI / 8;
                    bodySegment.add(rightLeg);
                    legs.push(rightLeg);
                }
            }

            // --- Game State Variables ---
            let controlMode = 'mouse';
            let handTargetPos = new THREE.Vector3(0, 0, 0);
            let mood = "content";
            let lastMousePos = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
            let mouseSpeed = 0;
            let lastMovementTime = Date.now();
            let clickCount = 0;
            let lastClickTime = 0;
            let angryTimer = 0;
            let randomTarget = new THREE.Vector3(0, 0, 0);
            let lastTargetChange = Date.now();
            let llmIsLoading = false;

            // UI elements
            const moodDisplay = document.getElementById('mood-display');
            const cheerUpBtn = document.getElementById('cheer-up-btn');
            const llmResponseBox = document.getElementById('llm-response-box');
            const llmResponseText = document.getElementById('llm-response-text');
            const closeBtn = llmResponseBox.querySelector('.close-btn');
            const controlSwitchBtn = document.getElementById('control-switch-btn');
            const debugToggleBtn = document.getElementById('debug-toggle-btn');
            const debugInfo = document.getElementById('debug-info');

            // Debug elements
            const controlModeSpan = document.getElementById('control-mode');
            const handStatusSpan = document.getElementById('hand-status');
            const gestureStatusSpan = document.getElementById('gesture-status');
            const cameraStatusSpan = document.getElementById('camera-status');

            const moodColors = { "bored": 0x646464, "content": 0x32CD32, "playful": 0x00ff00, "sad": 0x464696, "angry": 0xff3232 };

            // --- MediaPipe Hand Tracking Setup ---
            const videoElement = document.querySelector('.input_video');
            let hands, camera_mp;
            let isHandTrackingActive = false;
            let lastGestureTime = 0;
            let currentGesture = 'none';

            function detectGesture(landmarks) {
                const indexTip = landmarks[8];
                const thumbTip = landmarks[4];
                const middleTip = landmarks[12];
                const ringTip = landmarks[16];
                const pinkyTip = landmarks[20];

                const indexPip = landmarks[6];
                const middlePip = landmarks[10];
                const ringPip = landmarks[14];
                const pinkyPip = landmarks[18];
                const thumbCmc = landmarks[2];

                const pinchDistance = Math.sqrt(Math.pow(indexTip.x - thumbTip.x, 2) + Math.pow(indexTip.y - thumbTip.y, 2) + Math.pow(indexTip.z - thumbTip.z, 2));
                const isFist = indexTip.y > indexPip.y && middleTip.y > middlePip.y && ringTip.y > ringPip.y && pinkyTip.y > pinkyPip.y && thumbTip.x < thumbCmc.x;
                const isOpenPalm = indexTip.y < indexPip.y && middleTip.y < middlePip.y && ringTip.y < ringPip.y && pinkyTip.y < pinkyPip.y;

                if (isFist) return 'fist';
                if (pinchDistance < 0.08) return 'pinch';
                if (isOpenPalm) return 'open_palm';
                return 'point';
            }

            function onResults(results) {
                if (controlMode !== 'hand') return;

                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const landmarks = results.multiHandLandmarks[0];
                    handStatusSpan.textContent = 'Yes';

                    const indexTip = landmarks[8];
                    handTargetPos.set((1 - indexTip.x) * 40 - 20, -(indexTip.y) * 40 + 20, 0);
                    lastMovementTime = Date.now();

                    const detectedGesture = detectGesture(landmarks);
                    currentGesture = detectedGesture;
                    gestureStatusSpan.textContent = detectedGesture;

                    const now = Date.now();
                    if (now - lastGestureTime > 500) { // 500ms debounce
                        switch (detectedGesture) {
                            case 'fist':
                                mood = "angry";
                                angryTimer = now;
                                break;
                            case 'pinch':
                                mood = "playful";
                                break;
                            case 'open_palm':
                                mood = "content";
                                break;
                        }
                        lastGestureTime = now;
                    }
                } else {
                    handStatusSpan.textContent = 'No';
                    gestureStatusSpan.textContent = 'None';
                }
            }

            async function startHandTracking() {
                try {
                    cameraStatusSpan.textContent = 'Starting...';

                    hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
                    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
                    hands.onResults(onResults);

                    camera_mp = new Camera(videoElement, {
                        onFrame: async () => { await hands.send({ image: videoElement }); },
                        width: 640,
                        height: 480
                    });

                    await camera_mp.start();
                    isHandTrackingActive = true;
                    cameraStatusSpan.textContent = 'Active';
                    videoElement.style.display = 'block';

                } catch (error) {
                    console.error('Hand tracking initialization failed:', error);
                    cameraStatusSpan.textContent = 'Error';
                    alert('Hand tracking failed to start. Please ensure camera permissions are granted and no other app is using the camera.');
                }
            }

            function stopHandTracking() {
                if (camera_mp) {
                    camera_mp.stop();
                    isHandTrackingActive = false;
                    cameraStatusSpan.textContent = 'Off';
                    videoElement.style.display = 'none';
                }
            }

            // --- Event Listeners ---
            controlSwitchBtn.addEventListener('click', async () => {
                if (controlMode === 'mouse') {
                    controlMode = 'hand';
                    controlSwitchBtn.innerHTML = "Switch to Mouse Control üñ±Ô∏è";
                    controlModeSpan.textContent = 'Hand';
                    await startHandTracking();
                } else {
                    controlMode = 'mouse';
                    controlSwitchBtn.innerHTML = "Switch to Hand Control üñêÔ∏è";
                    controlModeSpan.textContent = 'Mouse';
                    stopHandTracking();
                }
            });

            debugToggleBtn.addEventListener('click', () => {
                if (debugInfo.style.display === 'none') {
                    debugInfo.style.display = 'block';
                    debugToggleBtn.textContent = 'Hide Debug';
                } else {
                    debugInfo.style.display = 'none';
                    debugToggleBtn.textContent = 'Debug Info';
                }
            });

            window.addEventListener('mousemove', (event) => {
                if (controlMode !== 'mouse') return;
                const dx = event.clientX - lastMousePos.x;
                const dy = event.clientY - lastMousePos.y;
                mouseSpeed = Math.sqrt(dx * dx + dy * dy);
                lastMousePos = { x: event.clientX, y: event.clientY };
                lastMovementTime = Date.now();
            });

            window.addEventListener('mousedown', (event) => {
                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2();
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(bodyParts, true);

                if (intersects.length > 0) {
                    const now = Date.now();
                    if (now - lastClickTime < 500) {
                        clickCount++;
                    } else {
                        clickCount = 1;
                    }
                    lastClickTime = now;
                }
            });

            cheerUpBtn.addEventListener('click', () => {
                mood = 'playful';
                angryTimer = 0;
            });

            closeBtn.addEventListener('click', () => {
                llmResponseBox.style.display = 'none';
            });

            // --- Animation Loop ---
            function animate() {
                requestAnimationFrame(animate);

                const now = Date.now();
                const timeSinceMovement = (now - lastMovementTime) / 1000;

                if (clickCount >= 3 && now - lastClickTime < 1500) {
                    mood = "angry";
                    angryTimer = now;
                    clickCount = 0;
                }

                if (controlMode === 'mouse' || !isHandTrackingActive) {
                    if (mood === "angry") {
                        if (mouseSpeed < 5 && now - angryTimer > 3000) {
                            mood = "content";
                        } else if (now - angryTimer > 10000) {
                            mood = "content";
                        }
                    } else if (mood === 'playful') {
                        if (timeSinceMovement > 5) {
                            mood = 'content';
                        }
                    } else {
                        if (mouseSpeed > 50 && controlMode === 'mouse') {
                            mood = "playful";
                        } else if (timeSinceMovement > 15) {
                            mood = "angry";
                            angryTimer = now;
                        } else if (timeSinceMovement > 10) {
                            mood = "sad";
                        } else if (timeSinceMovement > 3) {
                            mood = "bored";
                        } else {
                            mood = "content";
                        }
                    }
                }

                moodDisplay.innerText = `Mood: ${mood.charAt(0).toUpperCase() + mood.slice(1)}`;

                const targetPosition = new THREE.Vector3();
                if (mood === "angry") {
                    if (now - lastTargetChange > 2000) {
                        randomTarget.set((Math.random() - 0.5) * 50, (Math.random() - 0.5) * 50, (Math.random() - 0.5) * 50);
                        lastTargetChange = now;
                    }
                    targetPosition.copy(randomTarget);
                } else {
                    if (controlMode === 'mouse') {
                        targetPosition.set((lastMousePos.x / window.innerWidth) * 40 - 20, -(lastMousePos.y / window.innerHeight) * 40 + 20, 0);
                    } else {
                        targetPosition.copy(handTargetPos);
                    }
                }

                head.position.lerp(targetPosition, 0.05);
                for (let i = 1; i < bodyParts.length; i++) {
                    bodyParts[i].position.lerp(bodyParts[i - 1].position, 0.1);
                }

                const pulse = 1 + Math.sin(now * 0.005) * 0.1;
                head.scale.set(pulse, pulse, pulse);
                const time = now * 0.01;

                if (mood === 'playful') {
                    arms.forEach(arm => { arm.rotation.z = Math.sin(time * 2); });
                    legs.forEach(leg => { leg.rotation.x = Math.sin(time); });
                } else if (mood === 'angry') {
                    arms.forEach(arm => { arm.rotation.x = -Math.PI / 2; });
                    legs.forEach(leg => { leg.rotation.x = 0; });
                } else {
                    arms.forEach(arm => { arm.rotation.set(0, 0, 0); });
                    legs.forEach(leg => { leg.rotation.set(0, 0, Math.PI / 8 * (leg.position.x > 0 ? -1 : 1)); });
                }

                const sadColor = new THREE.Color(0x5555ff);
                if (mood === 'sad') {
                    eyes.forEach(eye => eye.material.color.lerp(sadColor, 0.1));
                } else {
                    eyes.forEach(eye => eye.material.color.lerp(new THREE.Color(0x000000), 0.1));
                }

                const smileRotationZ = -Math.PI / 2;
                const frownRotationZ = Math.PI / 2;

                switch (mood) {
                    case 'content':
                    case 'playful':
                        mouth.rotation.z = smileRotationZ;
                        mouth.scale.set(1, 1, 1);
                        eyebrows.forEach(b => b.visible = false);
                        break;
                    case 'sad':
                        mouth.rotation.z = frownRotationZ;
                        mouth.scale.set(0.7, 1, 1);
                        eyebrows.forEach(b => b.visible = true);
                        eyebrows[0].rotation.z = -Math.PI / 8;
                        eyebrows[1].rotation.z = Math.PI / 8;
                        break;
                    case 'angry':
                        mouth.rotation.z = frownRotationZ;
                        mouth.scale.set(1, 0.7, 1);
                        eyebrows.forEach(b => b.visible = true);
                        eyebrows[0].rotation.z = Math.PI / 8;
                        eyebrows[1].rotation.z = -Math.PI / 8;
                        break;
                    case 'bored':
                        mouth.rotation.z = smileRotationZ;
                        mouth.scale.set(1, 0.1, 1);
                        eyebrows.forEach(b => b.visible = false);
                        break;
                }

                const currentColor = new THREE.Color(head.material.color);
                const targetColor = new THREE.Color(moodColors[mood]);
                currentColor.lerp(targetColor, 0.05);

                bodyParts.forEach(part => {
                    part.material.color.copy(currentColor);
                    part.children.forEach(child => {
                        if (child.isMesh && child.material) {
                            if (eyes.indexOf(child) === -1 && child !== mouth && eyebrows.indexOf(child) === -1) {
                                child.material.color.copy(currentColor);
                            }
                        }
                    });
                });

                renderer.render(scene, camera);
            }

            // Start animation loop
            animate();

            // Handle window resize
            window.addEventListener('resize', () => {
                const newWidth = window.innerWidth;
                const newHeight = window.innerHeight;
                renderer.setSize(newWidth, newHeight);
                camera.aspect = newWidth / newHeight;
                camera.updateProjectionMatrix();
            });
        };
    </script>
</body>

</html>